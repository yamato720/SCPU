# RISC-V R-Type 完整测试指令说明

## 测试环境配置

### 寄存器初始值 (通过 ADDI 指令设置)
| 寄存器 | 初始值 (十进制) | 初始值 (十六进制) | 初始值 (二进制) |
|--------|----------------|-------------------|-----------------|
| x0     | 0              | 0x00000000        | 0000 0000       |
| x1     | 15             | 0x0000000F        | 0000 1111       |
| x2     | 10             | 0x0000000A        | 0000 1010       |
| x3     | 5              | 0x00000005        | 0000 0101       |
| x4     | 2              | 0x00000002        | 0000 0010       |
| x5     | -8             | 0xFFFFFFF8        | 1111...1000     |
| x6-x31 | 0              | 0x00000000        | 0000 0000       |

## 完整指令编码列表 (便于 BRAM 初始化)

```
地址 | 指令编码     | 汇编指令
-----|-------------|------------------
0x00 | h00F00093  | ADDI x1, x0, 15
0x04 | h00A00113  | ADDI x2, x0, 10
0x08 | h00500193  | ADDI x3, x0, 5
0x0C | h00200213  | ADDI x4, x0, 2
0x10 | hFF800293  | ADDI x5, x0, -8
0x14 | h00208333  | ADD  x6, x1, x2
0x18 | h403083B3  | SUB  x7, x1, x3
0x1C | h0020F433  | AND  x8, x1, x2
0x20 | h0030E4B3  | OR   x9, x1, x3
0x24 | h0030C533  | XOR  x10, x1, x3
0x28 | h0011A5B3  | SLT  x11, x3, x1
0x2C | h0030A633  | SLT  x12, x1, x3
0x30 | h004096B3  | SLL  x13, x1, x4
0x34 | h0021B733  | SLTU x14, x3, x2
0x38 | h0032B7B3  | SLTU x15, x5, x3
0x3C | h0040D833  | SRL  x16, x1, x4
0x40 | h4042D8B3  | SRA  x17, x5, x4
0x44 | h00730933  | ADD  x18, x6, x7
0x48 | h00000013  | NOP  (ADDI x0, x0, 0)
```

## 初始化指令序列

### 指令 0: ADDI x1, x0, 15
- **编码**: `0x00F00093`
- **格式**: I-type (imm[11:0]=15, rs1=x0, funct3=000, rd=x1, opcode=0010011)
- **操作**: x1 = x0 + 15 = **15**
- **预期结果**: x1 = 0x0000000F

### 指令 1: ADDI x2, x0, 10
- **编码**: `0x00A00113`
- **格式**: I-type (imm[11:0]=10, rs1=x0, funct3=000, rd=x2, opcode=0010011)
- **操作**: x2 = x0 + 10 = **10**
- **预期结果**: x2 = 0x0000000A

### 指令 2: ADDI x3, x0, 5
- **编码**: `0x00500193`
- **格式**: I-type (imm[11:0]=5, rs1=x0, funct3=000, rd=x3, opcode=0010011)
- **操作**: x3 = x0 + 5 = **5**
- **预期结果**: x3 = 0x00000005

### 指令 3: ADDI x4, x0, 2
- **编码**: `0x00200213`
- **格式**: I-type (imm[11:0]=2, rs1=x0, funct3=000, rd=x4, opcode=0010011)
- **操作**: x4 = x0 + 2 = **2**
- **预期结果**: x4 = 0x00000002

### 指令 4: ADDI x5, x0, -8
- **编码**: `0xFF800293`
- **格式**: I-type (imm[11:0]=-8, rs1=x0, funct3=000, rd=x5, opcode=0010011)
- **操作**: x5 = x0 + (-8) = **-8**
- **预期结果**: x5 = 0xFFFFFFF8

## R-Type 测试指令序列

### 指令 5: ADD x6, x1, x2
- **编码**: `0x00208333`
- **格式**: R-type (funct7=0000000, rs2=x2, rs1=x1, funct3=000, rd=x6, opcode=0110011)
- **操作**: x6 = x1 + x2 = 15 + 10 = **25**
- **ALU 控制码**: 0000 (ADD)
- **预期结果**: x6 = 0x00000019

### 指令 6: SUB x7, x1, x3
- **编码**: `0x403083B3`
- **格式**: R-type (funct7=0100000, rs2=x3, rs1=x1, funct3=000, rd=x7, opcode=0110011)
- **操作**: x7 = x1 - x3 = 15 - 5 = **10**
- **ALU 控制码**: 0001 (SUB)
- **预期结果**: x7 = 0x0000000A

### 指令 7: AND x8, x1, x2
- **编码**: `0x0020F433`
- **格式**: R-type (funct7=0000000, rs2=x2, rs1=x1, funct3=111, rd=x8, opcode=0110011)
- **操作**: x8 = x1 & x2 = 15 & 10 = **10**
- **二进制**: 0000_1111 & 0000_1010 = 0000_1010
- **ALU 控制码**: 0011 (AND)
- **预期结果**: x8 = 0x0000000A

### 指令 8: OR x9, x1, x3
- **编码**: `0x0030E4B3`
- **格式**: R-type (funct7=0000000, rs2=x3, rs1=x1, funct3=110, rd=x9, opcode=0110011)
- **操作**: x9 = x1 | x3 = 15 | 5 = **15**
- **二进制**: 0000_1111 | 0000_0101 = 0000_1111
- **ALU 控制码**: 0100 (OR)
- **预期结果**: x9 = 0x0000000F

### 指令 9: XOR x10, x1, x3
- **编码**: `0x0030C533`
- **格式**: R-type (funct7=0000000, rs2=x3, rs1=x1, funct3=100, rd=x10, opcode=0110011)
- **操作**: x10 = x1 ^ x3 = 15 ^ 5 = **10**
- **二进制**: 0000_1111 ^ 0000_0101 = 0000_1010
- **ALU 控制码**: 0101 (XOR)
- **预期结果**: x10 = 0x0000000A

### 指令 10: SLT x11, x3, x1
- **编码**: `0x0011A5B3`
- **格式**: R-type (funct7=0000000, rs2=x1, rs1=x3, funct3=010, rd=x11, opcode=0110011)
- **操作**: x11 = (x3 < x1) ? 1 : 0 = (5 < 15) ? 1 : 0 = **1** (有符号比较)
- **ALU 控制码**: 0110 (SLT - Set Less Than)
- **预期结果**: x11 = 0x00000001

### 指令 11: SLT x12, x1, x3
- **编码**: `0x0030A633`
- **格式**: R-type (funct7=0000000, rs2=x3, rs1=x1, funct3=010, rd=x12, opcode=0110011)
- **操作**: x12 = (x1 < x3) ? 1 : 0 = (15 < 5) ? 1 : 0 = **0**
- **ALU 控制码**: 0110 (SLT)
- **预期结果**: x12 = 0x00000000

### 指令 12: SLL x13, x1, x4
- **编码**: `0x004096B3`
- **格式**: R-type (funct7=0000000, rs2=x4, rs1=x1, funct3=001, rd=x13, opcode=0110011)
- **操作**: x13 = x1 << x4 = 15 << 2 = **60**
- **二进制**: 0000_1111 << 2 = 0011_1100
- **ALU 控制码**: 1000 (SLL - Shift Left Logical)
- **预期结果**: x13 = 0x0000003C

### 指令 13: SLTU x14, x3, x2
- **编码**: `0x0021B733`
- **格式**: R-type (funct7=0000000, rs2=x2, rs1=x3, funct3=011, rd=x14, opcode=0110011)
- **操作**: x14 = (x3 < x2) ? 1 : 0 = (5 < 10) ? 1 : 0 = **1** (无符号比较)
- **ALU 控制码**: 1001 (SLTU - Set Less Than Unsigned)
- **预期结果**: x14 = 0x00000001

### 指令 14: SLTU x15, x5, x3
- **编码**: `0x0032B7B3`
- **格式**: R-type (funct7=0000000, rs2=x3, rs1=x5, funct3=011, rd=x15, opcode=0110011)
- **操作**: x15 = (x5 < x3) ? 1 : 0 = (0xFFFFFFF8 < 5) ? 1 : 0 = **0** (无符号: -8作为大数)
- **ALU 控制码**: 1001 (SLTU)
- **预期结果**: x15 = 0x00000000

### 指令 15: SRL x16, x1, x4
- **编码**: `0x0040D833`
- **格式**: R-type (funct7=0000000, rs2=x4, rs1=x1, funct3=101, rd=x16, opcode=0110011)
- **操作**: x16 = x1 >> x4 = 15 >> 2 = **3** (逻辑右移)
- **二进制**: 0000_1111 >> 2 = 0000_0011
- **ALU 控制码**: 1010 (SRL - Shift Right Logical)
- **预期结果**: x16 = 0x00000003

### 指令 16: SRA x17, x5, x4
- **编码**: `0x4042D8B3`
- **格式**: R-type (funct7=0100000, rs2=x4, rs1=x5, funct3=101, rd=x17, opcode=0110011)
- **操作**: x17 = x5 >>> x4 = -8 >>> 2 = **-2** (算术右移，保留符号)
- **二进制**: 1111...1000 >>> 2 = 1111...1110
- **ALU 控制码**: 1011 (SRA - Shift Right Arithmetic)
- **预期结果**: x17 = 0xFFFFFFFE

### 指令 17: ADD x18, x6, x7
- **编码**: `0x00730933`
- **格式**: R-type (funct7=0000000, rs2=x7, rs1=x6, funct3=000, rd=x18, opcode=0110011)
- **操作**: x18 = x6 + x7 = 25 + 10 = **35** (测试依赖链)
- **ALU 控制码**: 0000 (ADD)
- **预期结果**: x18 = 0x00000023

### 指令 18: NOP
- **编码**: `0x00000013`
- **格式**: I-type (ADDI x0, x0, 0)
- **操作**: 无操作
- **预期结果**: 无状态改变

## ALU 操作覆盖情况

| ALU 控制码 | 操作名称 | RISC-V 指令 | 测试指令编号 | 测试状态 |
|-----------|---------|-------------|-------------|---------|
| 0000      | ADD     | ADD         | 5, 17       | ✅ 已测试 |
| 0001      | SUB     | SUB         | 6           | ✅ 已测试 |
| 0010      | NOT     | -           | -           | ⚠️ 不支持 (ALU 实现但无 R-type 映射) |
| 0011      | AND     | AND         | 7           | ✅ 已测试 |
| 0100      | OR      | OR          | 8           | ✅ 已测试 |
| 0101      | XOR     | XOR         | 9           | ✅ 已测试 |
| 0110      | SLT     | SLT         | 10, 11      | ✅ 已测试 |
| 0111      | EQU     | -           | -           | ⚠️ 不支持 (ALU 实现但无 R-type 映射) |
| 1000      | SLL     | SLL         | 12          | ✅ 已测试 |
| 1001      | SLTU    | SLTU        | 13, 14      | ✅ 已测试 |
| 1010      | SRL     | SRL         | 15          | ✅ 已测试 |
| 1011      | SRA     | SRA         | 16          | ✅ 已测试 |

## 预期寄存器最终状态

执行完所有指令后，寄存器应包含以下值：

| 寄存器 | 值 (十进制) | 值 (十六进制) | 备注 / 操作 |
|--------|------------|---------------|------------|
| x0     | 0          | 0x00000000    | 恒为 0 (硬件固定) |
| x1     | 15         | 0x0000000F    | ADDI 初始化 |
| x2     | 10         | 0x0000000A    | ADDI 初始化 |
| x3     | 5          | 0x00000005    | ADDI 初始化 |
| x4     | 2          | 0x00000002    | ADDI 初始化 |
| x5     | -8         | 0xFFFFFFF8    | ADDI 初始化 (负数) |
| x6     | 25         | 0x00000019    | ADD: x1 + x2 |
| x7     | 10         | 0x0000000A    | SUB: x1 - x3 |
| x8     | 10         | 0x0000000A    | AND: x1 & x2 |
| x9     | 15         | 0x0000000F    | OR: x1 \| x3 |
| x10    | 10         | 0x0000000A    | XOR: x1 ^ x3 |
| x11    | 1          | 0x00000001    | SLT: x3 < x1 (true) |
| x12    | 0          | 0x00000000    | SLT: x1 < x3 (false) |
| x13    | 60         | 0x0000003C    | SLL: x1 << 2 |
| x14    | 1          | 0x00000001    | SLTU: 5 < 10 (无符号) |
| x15    | 0          | 0x00000000    | SLTU: -8 < 5 (无符号false) |
| x16    | 3          | 0x00000003    | SRL: x1 >> 2 |
| x17    | -2         | 0xFFFFFFFE    | SRA: x5 >>> 2 |
| x18    | 35         | 0x00000023    | ADD: x6 + x7 |
| x19-x31| 0          | 0x00000000    | 未使用 |

## R-Type 指令格式说明

所有 R-type 指令的格式为：
```
funct7[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
```
- **opcode**: 0110011 (R-type 固定)
- **funct7**: 0000000 (大部分指令) 或 0100000 (SUB, SRA)
- **funct3**: 根据具体指令变化

## ALU_ctrl 映射表

| funct7[5] | funct3 | ALU 控制码 | 指令 | 操作 |
|-----------|--------|-----------|------|------|
| 0         | 000    | 0000      | ADD  | rd = rs1 + rs2 |
| 1         | 000    | 0001      | SUB  | rd = rs1 - rs2 |
| 0         | 111    | 0011      | AND  | rd = rs1 & rs2 |
| 0         | 110    | 0100      | OR   | rd = rs1 \| rs2 |
| 0         | 100    | 0101      | XOR  | rd = rs1 ^ rs2 |
| 0         | 010    | 0110      | SLT  | rd = (rs1 < rs2) ? 1 : 0 (有符号) |
| 0         | 001    | 1000      | SLL  | rd = rs1 << rs2[4:0] |
| 0         | 011    | 1001      | SLTU | rd = (rs1 < rs2) ? 1 : 0 (无符号) |
| 1         | 101    | 1010      | SRL  | rd = rs1 >> rs2[4:0] (逻辑) |
| 1         | 101    | 1011      | SRA  | rd = rs1 >>> rs2[4:0] (算术) |

## 特殊说明

### NOT 和 EQU 操作
- **NOT (0010)**: ALU 内部实现，但未映射到标准 RISC-V R-type 指令
  - 替代方案: 使用 I-type 指令 `XORI rd, rs1, -1`
- **EQU (0111)**: ALU 内部实现，但未映射到标准 RISC-V R-type 指令
  - 替代方案: 使用分支指令的比较逻辑 (BEQ/BNE)

### 移位指令说明
- **SLL/SRL/SRA**: 只使用 rs2 的低 5 位 (rs2[4:0]) 作为移位量，最大移位 31 位
- **SRA**: 算术右移，保留符号位 (对负数右移时高位填充 1)
- **SRL**: 逻辑右移，高位填充 0

### 有符号 vs 无符号
- **SLT**: 有符号比较，负数小于正数
- **SLTU**: 无符号比较，所有数按无符号整数处理

## 验证方法

1. 在仿真环境中运行测试台 (`tb_fetch.v` 或 `tb_top.v`)
2. 加载指令到 BRAM (`bram_8_4096_ins_shell.v`)
3. 观察每个时钟周期后寄存器文件的值
4. 对比实际结果与预期结果表
5. 检查 ALU 输出的 `zero`、`cout`、`overflow` 标志是否正确

## 测试覆盖率

- ✅ **10 种 R-type 指令**全部覆盖
- ✅ **基本算术**: ADD, SUB
- ✅ **逻辑运算**: AND, OR, XOR
- ✅ **比较指令**: SLT (有符号), SLTU (无符号)
- ✅ **移位指令**: SLL, SRL, SRA
- ✅ **依赖测试**: 指令 17 依赖指令 5 和 6 的结果
- ✅ **边界情况**: 负数算术右移 (SRA)、无符号比较 (SLTU)

## 相关文件

1. **rtl/ALU_ctrl.v**: ALU 控制逻辑，R-type 指令解码
2. **rtl/ALU.v**: ALU 运算单元实现
3. **rtl/Registers.v**: 寄存器文件 (初始值设为 0，通过 ADDI 初始化)
4. **rtl/Opcode_ctrl.v**: 主控制器，设置 aluop=2'b10 for R-type
5. **BRAM 初始化文件**: 存储测试指令的机器码
