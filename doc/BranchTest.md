# RISC-V 条件分支 (SB-Type) 和无条件跳转 (JAL/JALR) 完整测试指令说明

## 测试环境配置

### 寄存器初始值 (通过 ADDI 设置)
| 寄存器 | 初始值 (十进制) | 初始值 (十六进制) | 用途说明 |
|--------|----------------|-------------------|----------|
| x0     | 0              | 0x00000000        | 恒为 0 (硬件固定) |
| x1     | 10             | 0x0000000A        | 比较测试值1 (正数) |
| x2     | 20             | 0x00000014        | 比较测试值2 (正数) |
| x3     | 10             | 0x0000000A        | 比较测试值3 (等于x1) |
| x4     | -5             | 0xFFFFFFFB        | 比较测试值4 (负数) |
| x5     | 15             | 0x0000000F        | 比较测试值5 (中间值) |
| x6-x9  | 0              | 0x00000000        | 用于标记分支是否执行 |
| x10    | -              | -                 | JAL 返回地址 (ra1) |
| x11    | -              | -                 | JALR 返回地址 (ra2) |
| x12-x31| 0              | 0x00000000        | 未使用 |

## 完整指令编码列表 (便于 BRAM 初始化)

|地址 | 指令编码     | 汇编指令                    | 说明|
|-----|-------------|----------------------------|------|
|0x00 | 0x00A00093  | ADDI x1, x0, 10            | x1 = 10|
|0x04 | 0x01400113  | ADDI x2, x0, 20            | x2 = 20|
|0x08 | 0x00A00193  | ADDI x3, x0, 10            | x3 = 10 (等于x1)|
|0x0C | 0xFFB00213  | ADDI x4, x0, -5            | x4 = -5 (负数)|
|0x10 | 0x00F00293  | ADDI x5, x0, 15            | x5 = 15|
|0x14 | 0x00308463  | BEQ  x1, x3, 8             | x1==x3 (10==10) 跳转到0x1C|
|0x18 | 0x00100313  | ADDI x6, x0, 1             | (被跳过) x6 = 1|
|0x1C | 0x00209463  | BNE  x1, x2, 8             | x1!=x2 (10!=20) 跳转到0x24|
|0x20 | 0x00100393  | ADDI x7, x0, 1             | (被跳过) x7 = 1|
|0x24 | 0x00124463  | BLT  x4, x1, 8             | x4<x1 (-5<10) 跳转到0x2C|
|0x28 | 0x00100413  | ADDI x8, x0, 1             | (被跳过) x8 = 1|
|0x2C | 0x00115463  | BGE  x2, x1, 8             | x2>=x1 (20>=10) 跳转到0x34|
|0x30 | 0x00100493  | ADDI x9, x0, 1             | (被跳过) x9 = 1|
|0x34 | 0x0020E463  | BLTU x1, x2, 8             | x1<x2 unsigned (10<20) 跳转到0x3C|
|0x38 | 0x00100513  | ADDI x10, x0, 1            | (被跳过) x10 = 1|
|0x3C | 0x0012F463  | BGEU x5, x1, 8             | x5>=x1 unsigned (15>=10) 跳转到0x44|
|0x40 | 0x00100593  | ADDI x11, x0, 1            | (被跳过) x11 = 1|
|0x44 | 0x0140056F  | JAL  x10, 20               | 无条件跳转到0x58, x10=0x48|
|0x48 | 0x00000013  | NOP                        | (被跳过)|
|0x4C | 0x00000013  | NOP                        | (被跳过)|
|0x50 | 0x00000013  | NOP                        | (被跳过)|
|0x54 | 0x00000013  | NOP                        | (被跳过)|
|0x58 | 0x01E00613  | ADDI x12, x0, 30           | x12 = 30 (JAL目标)|
|0x5C | 0x008505E7  | JALR x11, 8(x10)           | 跳转到x10+8=0x50, x11=0x60|
|0x60 | 0x02800693  | ADDI x13, x0, 40           | x13 = 40 (JALR返回)|
|0x64 | 0x00000013  | NOP                        | 结束|

## 测试说明

### 初始化阶段（指令0-4，共5条）
- 使用 ADDI 指令初始化寄存器用于条件分支测试
  - x1: 10 (正数，用于相等比较)
  - x2: 20 (正数，大于x1)
  - x3: 10 (与x1相等)
  - x4: -5 (负数，有符号小于x1)
  - x5: 15 (介于x1和x2之间)

### 条件分支测试阶段（指令5-10，共6组测试）

每个条件分支后都有一条 ADDI 指令，如果分支跳转成功，该 ADDI 会被跳过。

#### 1. BEQ (Branch if Equal) 测试 - 地址 0x14
- **指令**: `BEQ x1, x3, 8`
- **条件**: x1 == x3 (10 == 10) → **成立，应该跳转**
- **跳转**: 0x14 → 0x14 + 8 = 0x1C
- **结果**: x6 保持 0 (0x18 的 ADDI 被跳过)

#### 2. BNE (Branch if Not Equal) 测试 - 地址 0x1C
- **指令**: `BNE x1, x2, 8`
- **条件**: x1 != x2 (10 != 20) → **成立，应该跳转**
- **跳转**: 0x1C → 0x1C + 8 = 0x24
- **结果**: x7 保持 0 (0x20 的 ADDI 被跳过)

#### 3. BLT (Branch if Less Than) 测试 - 地址 0x24
- **指令**: `BLT x4, x1, 8`
- **条件**: x4 < x1 有符号 (-5 < 10) → **成立，应该跳转**
- **跳转**: 0x24 → 0x24 + 8 = 0x2C
- **结果**: x8 保持 0 (0x28 的 ADDI 被跳过)

#### 4. BGE (Branch if Greater or Equal) 测试 - 地址 0x2C
- **指令**: `BGE x2, x1, 8`
- **条件**: x2 >= x1 有符号 (20 >= 10) → **成立，应该跳转**
- **跳转**: 0x2C → 0x2C + 8 = 0x34
- **结果**: x9 保持 0 (0x30 的 ADDI 被跳过)

#### 5. BLTU (Branch if Less Than Unsigned) 测试 - 地址 0x34
- **指令**: `BLTU x1, x2, 8`
- **条件**: x1 < x2 无符号 (10 < 20) → **成立，应该跳转**
- **跳转**: 0x34 → 0x34 + 8 = 0x3C
- **结果**: x10 保持 0 (0x38 的 ADDI 被跳过)

#### 6. BGEU (Branch if Greater or Equal Unsigned) 测试 - 地址 0x3C
- **指令**: `BGEU x5, x1, 8`
- **条件**: x5 >= x1 无符号 (15 >= 10) → **成立，应该跳转**
- **跳转**: 0x3C → 0x3C + 8 = 0x44
- **结果**: x11 保持 0 (0x40 的 ADDI 被跳过)

### 无条件跳转测试阶段（指令17-21）

#### 7. JAL (Jump and Link) 测试 - 地址 0x44
- **指令**: `JAL x10, 20`
- **操作**: 
  - PC 跳转: 0x44 → 0x44 + 20 = 0x58
  - 返回地址: x10 = PC + 4 = 0x48
- **跳过指令**: 0x48-0x54 的 4 条 NOP 被跳过
- **目标**: 执行 0x58 的 ADDI x12, x0, 30

#### 8. JALR (Jump and Link Register) 测试 - 地址 0x5C
- **指令**: `JALR x11, 8(x10)`
- **操作**:
  - 目标地址: (x10 + 8) & ~1 = (0x48 + 8) & ~1 = 0x50
  - 返回地址: x11 = PC + 4 = 0x60
  - PC 跳转: 0x5C → 0x50
- **跳转到**: 0x50 的 NOP
- **返回后**: 继续执行 0x60 的 ADDI x13, x0, 40

## 指令格式说明

### I-type (ADDI, JALR)
```
imm[11:0] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
```
- **ADDI opcode**: 0010011, funct3=000
- **JALR opcode**: 1100111, funct3=000
  - 目标地址 = (rs1 + imm) & ~1 (最低位清零确保对齐)
  - rd = PC + 4 (保存返回地址)

### B-type (BEQ, BNE, BLT, BGE, BLTU, BGEU)
```
imm[12|10:5] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[4:1|11] | opcode[6:0]
```
- **B-type opcode**: 1100011
- **funct3**:
  - BEQ: 000 (rs1 == rs2)
  - BNE: 001 (rs1 != rs2)
  - BLT: 100 (rs1 < rs2, 有符号)
  - BGE: 101 (rs1 >= rs2, 有符号)
  - BLTU: 110 (rs1 < rs2, 无符号)
  - BGEU: 111 (rs1 >= rs2, 无符号)
- 立即数编码: imm[12|10:5|4:1|11] (特殊位序，最低位隐含为0)
- 目标地址 = PC + sign_extend(imm) (imm 必须是 2 的倍数)
- **不保存返回地址**

### J-type (JAL)
```
imm[20|10:1|11|19:12] | rd[11:7] | opcode[6:0]
```
- **JAL opcode**: 1101111
- 立即数编码: imm[20|10:1|11|19:12] (特殊位序)
- 目标地址 = PC + sign_extend(imm)
- rd = PC + 4 (保存返回地址)

## Opcode_ctrl 控制信号

| 指令类型 | opcode  | funct3 | aluop | alu_src | mem_read | mem_write | mem2reg | reg_write | branch | jump |
|---------|---------|--------|-------|---------|----------|-----------|---------|-----------|--------|------|
| ADDI    | 0010011 | 000    | 11    | 1       | 0        | 0         | 0       | 1         | 0      | 0    |
| BEQ     | 1100011 | 000    | 01    | 0       | 0        | 0         | 0       | 0         | 1      | 0    |
| BNE     | 1100011 | 001    | 01    | 0       | 0        | 0         | 0       | 0         | 1      | 0    |
| BLT     | 1100011 | 100    | 01    | 0       | 0        | 0         | 0       | 0         | 1      | 0    |
| BGE     | 1100011 | 101    | 01    | 0       | 0        | 0         | 0       | 0         | 1      | 0    |
| BLTU    | 1100011 | 110    | 01    | 0       | 0        | 0         | 0       | 0         | 1      | 0    |
| BGEU    | 1100011 | 111    | 01    | 0       | 0        | 0         | 0       | 0         | 1      | 0    |
| JAL     | 1101111 | -      | -     | -       | 0        | 0         | 0       | 1         | 0      | 1    |
| JALR    | 1100111 | 000    | 11    | 1       | 0        | 0         | 0       | 1         | 0      | 1    |

### 分支条件判断 (通过 ALU_ctrl 和 ALU 完成)
- **BEQ/BNE**: ALU 执行减法，判断 Zero 标志
- **BLT/BGE**: ALU 执行有符号减法，判断符号位
- **BLTU/BGEU**: ALU 执行无符号减法，判断借位

## 预期寄存器最终状态

| 寄存器 | 值 (十进制) | 值 (十六进制) | 备注 / 操作 |
|--------|------------|---------------|------------|
| x0     | 0          | 0x00000000    | 恒为 0 (硬件固定) |
| x1     | 10         | 0x0000000A    | 初始化 (ADDI) |
| x2     | 20         | 0x00000014    | 初始化 (ADDI) |
| x3     | 10         | 0x0000000A    | 初始化 (ADDI) |
| x4     | -5         | 0xFFFFFFFB    | 初始化 (ADDI) |
| x5     | 15         | 0x0000000F    | 初始化 (ADDI) |
| x6     | 0          | 0x00000000    | BEQ 跳转成功，0x18 被跳过 |
| x7     | 0          | 0x00000000    | BNE 跳转成功，0x20 被跳过 |
| x8     | 0          | 0x00000000    | BLT 跳转成功，0x28 被跳过 |
| x9     | 0          | 0x00000000    | BGE 跳转成功，0x30 被跳过 |
| x10    | 72         | 0x00000048    | JAL 返回地址 (0x44+4) |
| x11    | 96         | 0x00000060    | JALR 返回地址 (0x5C+4) |
| x12    | 30         | 0x0000001E    | JAL 目标处设置 (ADDI) |
| x13    | 40         | 0x00000028    | JALR 返回后设置 (ADDI) |
| x14-x31| 0          | 0x00000000    | 未使用 |

**重要验证点**:
- x6-x9 都应该为 0，证明所有条件分支都成功跳转，跳过了后续的 ADDI 指令
- x10 = 0x48 证明 JAL 正确保存了返回地址
- x11 = 0x60 证明 JALR 正确保存了返回地址
- x12 = 30 证明 JAL 跳转到了正确的目标地址
- x13 = 40 证明 JALR 正确跳转并返回

## 程序执行流程图

```
地址      指令                    执行顺序
----------------------------------------------------------
0x00      ADDI x1, x0, 10        1. 初始化 x1=10
0x04      ADDI x2, x0, 20        2. 初始化 x2=20
0x08      ADDI x3, x0, 10        3. 初始化 x3=10
0x0C      ADDI x4, x0, -5        4. 初始化 x4=-5
0x10      ADDI x5, x0, 15        5. 初始化 x5=15
0x14  ┌─→ BEQ x1, x3, 8          6. x1==x3? 是 → 跳转到 0x1C
0x18  │   ADDI x6, x0, 1         (跳过，x6保持0)
0x1C  └─┬→BNE x1, x2, 8          7. x1!=x2? 是 → 跳转到 0x24
0x20    │ ADDI x7, x0, 1         (跳过，x7保持0)
0x24    └┬→BLT x4, x1, 8         8. x4<x1? 是 → 跳转到 0x2C
0x28     │ ADDI x8, x0, 1        (跳过，x8保持0)
0x2C     └┬→BGE x2, x1, 8        9. x2>=x1? 是 → 跳转到 0x34
0x30      │ ADDI x9, x0, 1       (跳过，x9保持0)
0x34      └┬→BLTU x1, x2, 8      10. x1<x2(unsigned)? 是 → 跳转到 0x3C
0x38       │ ADDI x10, x0, 1     (跳过，x10保持0)
0x3C       └┬→BGEU x5, x1, 8     11. x5>=x1(unsigned)? 是 → 跳转到 0x44
0x40        │ ADDI x11, x0, 1    (跳过，x11保持0)
0x44  ┌─────┴→JAL x10, 20        12. 无条件跳转到 0x58, x10=0x48
0x48  │       NOP                (跳过)
0x4C  │       NOP                (跳过)
0x50  │    ←┐ NOP                15. JALR 跳转到此
0x54  │     │ NOP                16. 执行 NOP (继续顺序执行)
0x58  └─────│→ADDI x12, x0, 30   13. JAL 目标, x12=30
0x5C        │ JALR x11, 8(x10)   14. 跳转到 x10+8=0x50, x11=0x60
0x60        └→ADDI x13, x0, 40   17. JALR 返回, x13=40
0x64          NOP                18. 结束
```

## 测试覆盖率

- ✅ **条件分支指令 (B-type, SB 类型)**:
  - BEQ (1次) - 相等分支，测试 x1 == x3
  - BNE (1次) - 不等分支，测试 x1 != x2
  - BLT (1次) - 有符号小于分支，测试 x4 < x1 (-5 < 10)
  - BGE (1次) - 有符号大于等于分支，测试 x2 >= x1 (20 >= 10)
  - BLTU (1次) - 无符号小于分支，测试 x1 < x2
  - BGEU (1次) - 无符号大于等于分支，测试 x5 >= x1
  - **覆盖所有 6 种条件分支指令**
  - 验证分支条件判断逻辑
  - 验证跳转地址计算 (PC + offset)
  - 验证分支成功时跳过后续指令

- ✅ **无条件跳转指令**:
  - JAL (1次) - PC 相对跳转，保存返回地址到 x10
  - JALR (1次) - 寄存器间接跳转，保存返回地址到 x11
  - 验证跳转目标计算
  - 验证返回地址保存 (PC + 4)
  - 验证跳过的指令不被执行

- ✅ **I-type 算术**: ADDI (5次初始化 + 2次测试 + 6次验证标记 = 13次)

- ✅ **控制流**:
  - 顺序执行
  - 条件分支 (6 种条件)
  - 前向跳转 (所有分支 + JAL)
  - 后向跳转 (JALR)
  - 跳转后继续执行
  - 分支预测验证 (通过检查寄存器是否被修改)

## 验证方法

1. 在仿真环境中运行测试台 (`tb_top.v`)
2. 加载指令到指令 BRAM
3. 观察执行流程:
   - **初始化阶段**: 检查 x1-x5 的值 (10, 20, 10, -5, 15)
   - **BEQ 测试**: PC 从 0x14 跳转到 0x1C，x6 保持 0
   - **BNE 测试**: PC 从 0x1C 跳转到 0x24，x7 保持 0
   - **BLT 测试**: PC 从 0x24 跳转到 0x2C，x8 保持 0
   - **BGE 测试**: PC 从 0x2C 跳转到 0x34，x9 保持 0
   - **BLTU 测试**: PC 从 0x34 跳转到 0x3C，x10 保持 0 (后被 JAL 覆盖)
   - **BGEU 测试**: PC 从 0x3C 跳转到 0x44，x11 保持 0 (后被 JALR 覆盖)
   - **JAL 测试**: PC 从 0x44 跳转到 0x58，x10=0x48，x12=30
   - **JALR 测试**: PC 从 0x5C 跳转到 0x50，x11=0x60，x13=40
4. **关键验证点**:
   - x6-x9 都应该为 0 (证明条件分支成功)
   - x10 = 0x48 (证明 JAL 返回地址正确)
   - x11 = 0x60 (证明 JALR 返回地址正确)
   - x12 = 30, x13 = 40 (证明跳转目标正确)
5. 验证跳过的指令不改变寄存器状态
6. 对比实际结果与预期结果表

## 相关文件

1. **rtl/Opcode_ctrl.v**: 主控制器，识别所有分支和跳转指令
2. **rtl/ALU.v**: ALU 用于分支条件判断 (相等、比较、无符号比较)
3. **rtl/ALU_ctrl.v**: ALU 控制器，根据 funct3 选择比较操作
4. **rtl/ImmGenerator.v**: 立即数生成器，处理 B-type 和 J-type 的特殊编码
5. **rtl/PC_ctrl.v**: PC 控制模块，处理分支和跳转逻辑
6. **rtl/Registers.v**: 寄存器文件
7. **BRAM 初始化文件**: 存储测试指令

## 注意事项

1. **B-type 立即数**: 
   - 编码位序: imm[12|10:5|4:1|11]
   - 最低位 imm[0] 隐含为 0 (地址必须 2 字节对齐)
   - 范围: -4096 到 +4094 (±4KB)
   
2. **分支条件判断**:
   - BEQ/BNE: 通过 ALU 减法，检查 Zero 标志
   - BLT/BGE: 有符号比较，检查符号位和溢出
   - BLTU/BGEU: 无符号比较，检查借位标志
   
3. **条件分支不保存返回地址**: 与 JAL/JALR 不同，B-type 指令不修改任何寄存器

4. **JALR 地址对齐**: 目标地址的最低位自动清零 `(rs1 + imm) & ~1`

5. **返回地址**: 只有 JAL/JALR 将 PC+4 保存到目标寄存器

6. **跳转范围**: 
   - B-type: 13 位有符号立即数，范围 ±4KB
   - JAL: 21 位有符号立即数，范围 ±1MB
   - JALR: 12 位有符号立即数 + 寄存器值，可达全地址空间
   
7. **测试验证**: 通过检查 x6-x9 是否保持 0 来验证所有条件分支都成功跳转
