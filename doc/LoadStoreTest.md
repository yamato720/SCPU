# RISC-V Load/Store 完整测试指令说明

## 测试环境配置

### 寄存器初始值 (通过 ADDI 指令设置)
| 寄存器 | 初始值 (十进制) | 初始值 (十六进制) | 用途说明 |
|--------|----------------|-------------------|----------|
| x0     | 0              | 0x00000000        | 恒为 0 (硬件固定) |
| x1     | 100            | 0x00000064        | 基地址指针 |
| x2     | 255            | 0x000000FF        | 测试数据 1 |
| x3     | 1024           | 0x00000400        | 测试数据 2 |
| x4     | -256           | 0xFFFFFF00        | 测试数据 3 (负数) |
| x5     | -1             | 0xFFFFFFFF        | 测试数据 4 (全 1) |
| x6     | 4              | 0x00000004        | 偏移量 +4 |
| x7     | 8              | 0x00000008        | 偏移量 +8 |
| x8-x15 | -              | -                 | 用于存储加载结果 |

### 内存布局 (基地址 = 100)
| 地址   | 初始内容       | Store 后内容   | 说明 |
|--------|---------------|---------------|------|
| 100    | 0x00000000    | 0x000000FF    | SW x2, 0(x1) |
| 104    | 0x00000000    | 0x00000400    | SW x3, 4(x1) |
| 108    | 0x00000000    | 0xFFFFFF00    | SW x4, 8(x1) |
| 112    | 0x00000000    | 0xFFFFFFFF    | SW x5, 12(x1) |

## 完整指令编码列表 (便于 BRAM 初始化)


|地址 | 指令编码     | 汇编指令                    | 说明|
|-----|-------------|----------------------------|------|
|0x00 | 0x06400093  | ADDI x1, x0, 100           | 基地址 = 100|
|0x04 | 0x0FF00113  | ADDI x2, x0, 255           | x2 = 255|
|0x08 | 0x40000193  | ADDI x3, x0, 1024          | x3 = 1024|
|0x0C | 0xF0000213  | ADDI x4, x0, -256          | x4 = -256|
|0x10 | 0xFFF00293  | ADDI x5, x0, -1            | x5 = -1|
|0x14 | 0x00400313  | ADDI x6, x0, 4             | x6 = 4|
|0x18 | 0x00800393  | ADDI x7, x0, 8             | x7 = 8|
|0x1C | 0x0020A023  | SW   x2, 0(x1)             | MEM[100] = x2|
|0x20 | 0x0030A223  | SW   x3, 4(x1)             | MEM[104] = x3|
|0x24 | 0x0040A423  | SW   x4, 8(x1)             | MEM[108] = x4|
|0x28 | 0x0050A623  | SW   x5, 12(x1)            | MEM[112] = x5|
|0x2C | 0x0000A403  | LW   x8, 0(x1)             | x8 = MEM[100]|
|0x30 | 0x0040A483  | LW   x9, 4(x1)             | x9 = MEM[104]|
|0x34 | 0x0080A503  | LW   x10, 8(x1)            | x10 = MEM[108]|
|0x38 | 0x00C0A583  | LW   x11, 12(x1)           | x11 = MEM[112]|
|0x3C | 0x00608633  | ADD  x12, x1, x6           | x12 = 104 (动态地址)|
|0x40 | 0x00062683  | LW   x13, 0(x12)           | x13 = MEM[104]|
|0x44 | 0x00C08733  | ADD  x14, x1, x12          | x14 = 204 (越界测试)|
|0x48 | 0x00072783  | LW   x15, 0(x14)           | x15 = MEM[204]|
|0x4C | 0x00000013  | NOP                        | 结束|


## 初始化指令序列 (指令 0-6)

### 指令 0: ADDI x1, x0, 100
- **编码**: `0x06400093`
- **格式**: I-type (imm=100, rs1=x0, funct3=000, rd=x1, opcode=0010011)
- **操作**: x1 = x0 + 100 = **100** (基地址)
- **预期结果**: x1 = 0x00000064

### 指令 1: ADDI x2, x0, 255
- **编码**: `0x0FF00113`
- **格式**: I-type (imm=255, rs1=x0, funct3=000, rd=x2, opcode=0010011)
- **操作**: x2 = x0 + 255 = **255**
- **预期结果**: x2 = 0x000000FF

### 指令 2: ADDI x3, x0, 1024
- **编码**: `0x40000193`
- **格式**: I-type (imm=1024, rs1=x0, funct3=000, rd=x3, opcode=0010011)
- **操作**: x3 = x0 + 1024 = **1024**
- **预期结果**: x3 = 0x00000400

### 指令 3: ADDI x4, x0, -256
- **编码**: `0xF0000213`
- **格式**: I-type (imm=-256 (0xF00), rs1=x0, funct3=000, rd=x4, opcode=0010011)
- **操作**: x4 = x0 + (-256) = **-256** (0xFFFFFF00)
- **预期结果**: x4 = 0xFFFFFF00

### 指令 4: ADDI x5, x0, -1
- **编码**: `0xFFF00293`
- **格式**: I-type (imm=-1 (0xFFF), rs1=x0, funct3=000, rd=x5, opcode=0010011)
- **操作**: x5 = x0 + (-1) = **-1** (0xFFFFFFFF)
- **预期结果**: x5 = 0xFFFFFFFF

### 指令 5: ADDI x6, x0, 4
- **编码**: `0x00400313`
- **格式**: I-type (imm=4, rs1=x0, funct3=000, rd=x6, opcode=0010011)
- **操作**: x6 = x0 + 4 = **4**
- **预期结果**: x6 = 0x00000004

### 指令 6: ADDI x7, x0, 8
- **编码**: `0x00800393`
- **格式**: I-type (imm=8, rs1=x0, funct3=000, rd=x7, opcode=0010011)
- **操作**: x7 = x0 + 8 = **8**
- **预期结果**: x7 = 0x00000008

## Store 指令测试 (指令 7-10)

### 指令 7: SW x2, 0(x1)
- **编码**: `0x0020A023`
- **格式**: S-type (imm[11:5]=0, rs2=x2, rs1=x1, funct3=010, imm[4:0]=0, opcode=0100011)
- **操作**: MEM[x1 + 0] = x2 → MEM[100] = **0x000000FF**
- **控制信号**: mem_write=1, alu_src=1, aluop=00
- **预期结果**: 内存地址 100 的值 = 0x000000FF

### 指令 8: SW x3, 4(x1)
- **编码**: `0x0030A223`
- **格式**: S-type (imm=4, rs2=x3, rs1=x1, funct3=010, opcode=0100011)
- **操作**: MEM[x1 + 4] = x3 → MEM[104] = **0x00000400**
- **预期结果**: 内存地址 104 的值 = 0x00000400

### 指令 9: SW x4, 8(x1)
- **编码**: `0x0040A423`
- **格式**: S-type (imm=8, rs2=x4, rs1=x1, funct3=010, opcode=0100011)
- **操作**: MEM[x1 + 8] = x4 → MEM[108] = **0xFFFFFF00**
- **预期结果**: 内存地址 108 的值 = 0xFFFFFF00

### 指令 10: SW x5, 12(x1)
- **编码**: `0x0050A623`
- **格式**: S-type (imm=12, rs2=x5, rs1=x1, funct3=010, opcode=0100011)
- **操作**: MEM[x1 + 12] = x5 → MEM[112] = **0xFFFFFFFF**
- **预期结果**: 内存地址 112 的值 = 0xFFFFFFFF

## Load 指令测试 (指令 11-14)

### 指令 11: LW x8, 0(x1)
- **编码**: `0x0000A403`
- **格式**: I-type (imm=0, rs1=x1, funct3=010, rd=x8, opcode=0000011)
- **操作**: x8 = MEM[x1 + 0] = MEM[100] = **0x000000FF**
- **控制信号**: mem_read=1, mem2reg=1, alu_src=1, aluop=00
- **预期结果**: x8 = 0x000000FF

### 指令 12: LW x9, 4(x1)
- **编码**: `0x0040A483`
- **格式**: I-type (imm=4, rs1=x1, funct3=010, rd=x9, opcode=0000011)
- **操作**: x9 = MEM[x1 + 4] = MEM[104] = **0x00000400**
- **预期结果**: x9 = 0x00000400

### 指令 13: LW x10, 8(x1)
- **编码**: `0x0080A503`
- **格式**: I-type (imm=8, rs1=x1, funct3=010, rd=x10, opcode=0000011)
- **操作**: x10 = MEM[x1 + 8] = MEM[108] = **0xFFFFFF00**
- **预期结果**: x10 = 0xFFFFFF00

### 指令 14: LW x11, 12(x1)
- **编码**: `0x00C0A583`
- **格式**: I-type (imm=12, rs1=x1, funct3=010, rd=x11, opcode=0000011)
- **操作**: x11 = MEM[x1 + 12] = MEM[112] = **0xFFFFFFFF**
- **预期结果**: x11 = 0xFFFFFFFF

## 动态地址测试 (指令 15-19)

### 指令 15: ADD x12, x1, x6
- **编码**: `0x00608633`
- **格式**: R-type (funct7=0000000, rs2=x6, rs1=x1, funct3=000, rd=x12, opcode=0110011)
- **操作**: x12 = x1 + x6 = 100 + 4 = **104** (使用 R-type 计算地址)
- **预期结果**: x12 = 0x00000068 (104)

### 指令 16: LW x13, 0(x12)
- **编码**: `0x00062683`
- **格式**: I-type (imm=0, rs1=x12, funct3=010, rd=x13, opcode=0000011)
- **操作**: x13 = MEM[x12 + 0] = MEM[104] = **0x00000400** (验证动态地址)
- **预期结果**: x13 = 0x00000400

### 指令 17: ADD x14, x1, x12
- **编码**: `0x00C08733`
- **格式**: R-type (funct7=0000000, rs2=x12, rs1=x1, funct3=000, rd=x14, opcode=0110011)
- **操作**: x14 = x1 + x12 = 100 + 104 = **204**
- **预期结果**: x14 = 0x000000CC (204)

### 指令 18: LW x15, 0(x14)
- **编码**: `0x00072783`
- **格式**: I-type (imm=0, rs1=x14, funct3=010, rd=x15, opcode=0000011)
- **操作**: x15 = MEM[204] (可能未初始化，测试边界行为)
- **预期结果**: x15 = 内存内容 (取决于初始化)

### 指令 19: NOP
- **编码**: `0x00000013`
- **格式**: I-type (ADDI x0, x0, 0)
- **操作**: 无操作
- **预期结果**: 无状态改变

## 指令格式说明

### I-type (Load 指令 + ADDI)
```
imm[11:0] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
```
- **Load opcode**: 0000011
- **ADDI opcode**: 0010011
- **funct3** (Load):
  - 000: LB (load byte, 有符号扩展)
  - 001: LH (load halfword, 有符号扩展)
  - 010: LW (load word)
  - 100: LBU (load byte, 零扩展)
  - 101: LHU (load halfword, 零扩展)

### S-type (Store 指令)
```
imm[11:5] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[4:0] | opcode[6:0]
```
- **opcode**: 0100011
- **funct3**:
  - 000: SB (store byte)
  - 001: SH (store halfword)
  - 010: SW (store word)

## Opcode_ctrl 控制信号

| 指令类型 | opcode  | aluop | alu_src | mem_read | mem_write | mem2reg | reg_write |
|---------|---------|-------|---------|----------|-----------|---------|-----------|
| Load    | 0000011 | 00    | 1       | 1        | 0         | 1       | 1         |
| Store   | 0100011 | 00    | 1       | 0        | 1         | 0       | 0         |
| I-type  | 0010011 | 11    | 1       | 0        | 0         | 0       | 1         |
| R-type  | 0110011 | 10    | 0       | 0        | 0         | 0       | 1         |

## 预期寄存器最终状态

| 寄存器 | 值 (十进制) | 值 (十六进制) | 备注 / 操作 |
|--------|------------|---------------|------------|
| x0     | 0          | 0x00000000    | 恒为 0 (硬件固定) |
| x1     | 100        | 0x00000064    | 基地址 (ADDI) |
| x2     | 255        | 0x000000FF    | 测试数据 1 (ADDI) |
| x3     | 1024       | 0x00000400    | 测试数据 2 (ADDI) |
| x4     | -256       | 0xFFFFFF00    | 测试数据 3 (ADDI) |
| x5     | -1         | 0xFFFFFFFF    | 测试数据 4 (ADDI) |
| x6     | 4          | 0x00000004    | 偏移量 (ADDI) |
| x7     | 8          | 0x00000008    | 偏移量 (ADDI) |
| x8     | 255        | 0x000000FF    | LW from MEM[100] |
| x9     | 1024       | 0x00000400    | LW from MEM[104] |
| x10    | -256       | 0xFFFFFF00    | LW from MEM[108] |
| x11    | -1         | 0xFFFFFFFF    | LW from MEM[112] |
| x12    | 104        | 0x00000068    | ADD x1 + x6 |
| x13    | 1024       | 0x00000400    | LW from MEM[104] (动态) |
| x14    | 204        | 0x000000CC    | ADD x1 + x12 |
| x15    | ?          | ?             | LW from MEM[204] (未定义) |
| x16-x31| 0          | 0x00000000    | 未使用 |

## 预期内存最终状态

| 地址 | 值 (十六进制) | 备注 |
|------|--------------|------|
| 100  | 0x000000FF   | SW x2, 0(x1) |
| 104  | 0x00000400   | SW x3, 4(x1) |
| 108  | 0xFFFFFF00   | SW x4, 8(x1) |
| 112  | 0xFFFFFFFF   | SW x5, 12(x1) |
| 204  | 0x00000000   | 未初始化 (或默认值) |

## 测试覆盖率

- ✅ **Load 指令**: LW (4 次直接 + 2 次动态地址)
- ✅ **Store 指令**: SW (4 次)
- ✅ **I-type 算术**: ADDI (7 次，全部用于初始化)
- ✅ **R-type 算术**: ADD (2 次，用于地址计算)
- ✅ **立即数扩展**: 正数、负数、12位范围内测试
- ✅ **内存访问**: 连续地址、动态地址、边界测试
- ✅ **数据模式**: 正数 (255, 1024)、负数 (-1, -256)

## DataMemory 时序说明

根据 `DataMemory.v` 实现，内存访问需要 **4 个时钟周期**：
1. **周期 1**: 地址稳定，发送地址到 BRAM
2. **周期 2**: 数据稳定 (读取低 16 位)
3. **周期 3**: 地址切换 (高 16 位地址)
4. **周期 4**: 数据稳定 (读取高 16 位)，完成读写

## 验证方法

1. 在仿真环境中运行测试台 (`tb_top.v` 或 `tb_mem.v`)
2. 加载指令到指令 BRAM (`bram_8_4096_ins_shell.v`)
3. 观察每个周期的寄存器和内存变化
4. 对比实际结果与预期结果表
5. 检查控制信号 (mem_read, mem_write, mem2reg) 是否正确
6. 验证 DataMemory 状态机在 4 周期内完成读写

## 相关文件

1. **rtl/Opcode_ctrl.v**: 主控制器，区分 Load/Store/I-type
2. **rtl/DataMemory.v**: 数据内存模块，支持双端口 BRAM
3. **rtl/ALU.v**: ALU 用于地址计算 (base + offset)
4. **rtl/ImmGenerator.v**: 立即数生成器，处理 I/S/U-type 立即数
5. **rtl/Registers.v**: 寄存器文件
6. **BRAM 初始化文件**: 存储测试指令和数据
