# RISC-V ALU 测试指令说明

## 测试环境配置

### 寄存器初始值 (在 Registers.v 中设置)
| 寄存器 | 初始值 (十进制) | 初始值 (十六进制) | 初始值 (二进制) |
|--------|----------------|-------------------|-----------------|
| x0     | 0              | 0x00000000        | 0000            |
| x1     | 15             | 0x0000000F        | 1111            |
| x2     | 10             | 0x0000000A        | 1010            |
| x3     | 5              | 0x00000005        | 0101            |
| x4-x31 | 0              | 0x00000000        | 0000            |

## 测试指令序列 (在 Ins_buffer.v 中定义)

### 指令 0: ADD x4, x1, x2
- **编码**: `0x00208233`
- **操作**: x4 = x1 + x2 = 15 + 10 = **25**
- **ALU 控制码**: 0000 (ADD)
- **预期结果**: x4 = 0x00000019 (25)

### 指令 1: SUB x5, x1, x3
- **编码**: `0x403082B3`
- **操作**: x5 = x1 - x3 = 15 - 5 = **10**
- **ALU 控制码**: 0001 (SUB)
- **预期结果**: x5 = 0x0000000A (10)

### 指令 2: AND x6, x1, x2
- **编码**: `0x0020F333`
- **操作**: x6 = x1 & x2 = 15 & 10 = **10**
- **二进制**: 1111 & 1010 = 1010
- **ALU 控制码**: 0011 (AND)
- **预期结果**: x6 = 0x0000000A (10)

### 指令 3: OR x7, x1, x3
- **编码**: `0x0030E3B3`
- **操作**: x7 = x1 | x3 = 15 | 5 = **15**
- **二进制**: 1111 | 0101 = 1111
- **ALU 控制码**: 0100 (OR)
- **预期结果**: x7 = 0x0000000F (15)

### 指令 4: XOR x8, x1, x3
- **编码**: `0x0030C433`
- **操作**: x8 = x1 ^ x3 = 15 ^ 5 = **10**
- **二进制**: 1111 ^ 0101 = 1010
- **ALU 控制码**: 0101 (XOR)
- **预期结果**: x8 = 0x0000000A (10)

### 指令 5: SLT x9, x3, x1
- **编码**: `0x0011A4B3`
- **操作**: x9 = (x3 < x1) ? 1 : 0 = (5 < 15) ? 1 : 0 = **1**
- **ALU 控制码**: 0110 (SLT - Set Less Than)
- **预期结果**: x9 = 0x00000001 (1)

### 指令 6: SLT x10, x1, x3
- **编码**: `0x0030A533`
- **操作**: x10 = (x1 < x3) ? 1 : 0 = (15 < 5) ? 1 : 0 = **0**
- **ALU 控制码**: 0110 (SLT)
- **预期结果**: x10 = 0x00000000 (0)

### 指令 7: ADD x11, x4, x5
- **编码**: `0x005205B3`
- **操作**: x11 = x4 + x5 = 25 + 10 = **35** (依赖前面指令的结果)
- **ALU 控制码**: 0000 (ADD)
- **预期结果**: x11 = 0x00000023 (35)

### 指令 8: SUB x12, x4, x3
- **编码**: `0x40320633`
- **操作**: x12 = x4 - x3 = 25 - 5 = **20** (依赖指令0的结果)
- **ALU 控制码**: 0001 (SUB)
- **预期结果**: x12 = 0x00000014 (20)

### 指令 9: NOP
- **编码**: `0x00000013`
- **操作**: ADDI x0, x0, 0 (无操作)
- **预期结果**: 无状态改变

## ALU 操作覆盖情况

| ALU 控制码 | 操作名称 | 测试指令编号 | 测试状态 |
|-----------|---------|-------------|---------|
| 0000      | ADD     | 0, 7        | ✅ 已测试 |
| 0001      | SUB     | 1, 8        | ✅ 已测试 |
| 0010      | NOT     | -           | ⚠️ 未测试 (需要更新 ALU_ctrl.v) |
| 0011      | AND     | 2           | ✅ 已测试 |
| 0100      | OR      | 3           | ✅ 已测试 |
| 0101      | XOR     | 4           | ✅ 已测试 |
| 0110      | SLT     | 5, 6        | ✅ 已测试 |
| 0111      | EQU     | -           | ⚠️ 未测试 (需要更新 ALU_ctrl.v) |

## 预期寄存器最终状态

执行完所有指令后，寄存器应包含以下值：

| 寄存器 | 值 (十进制) | 值 (十六进制) | 备注 |
|--------|------------|---------------|------|
| x0     | 0          | 0x00000000    | 恒为 0 |
| x1     | 15         | 0x0000000F    | 初始值保持 |
| x2     | 10         | 0x0000000A    | 初始值保持 |
| x3     | 5          | 0x00000005    | 初始值保持 |
| x4     | 25         | 0x00000019    | x1 + x2 |
| x5     | 10         | 0x0000000A    | x1 - x3 |
| x6     | 10         | 0x0000000A    | x1 & x2 |
| x7     | 15         | 0x0000000F    | x1 \| x3 |
| x8     | 10         | 0x0000000A    | x1 ^ x3 |
| x9     | 1          | 0x00000001    | x3 < x1 |
| x10    | 0          | 0x00000000    | x1 < x3 |
| x11    | 35         | 0x00000023    | x4 + x5 |
| x12    | 20         | 0x00000014    | x4 - x3 |
| x13-x31| 0          | 0x00000000    | 未使用 |

## 添加 NOT 和 EQU 测试的建议

目前 `ALU_ctrl.v` 中 NOT (0010) 和 EQU (0111) 操作没有映射到标准 RISC-V R-type 指令的 funct3/funct7 编码。

### 方案 1: 使用自定义扩展指令
在 `ALU_ctrl.v` 中添加自定义的 funct3/funct7 组合来触发 NOT 和 EQU 操作。

### 方案 2: 使用标准 RISC-V 指令模拟
- **NOT**: 可通过 `XORI rd, rs1, -1` (I-type) 实现按位取反
- **EQU**: 可通过 `SUB + 检查 Zero 标志` 实现相等判断

## 验证方法

1. 在仿真环境中运行 `tb_fetch.v` 测试台
2. 观察每个时钟周期后寄存器文件的值
3. 对比实际结果与预期结果表
4. 检查 ALU 输出的 `zero`、`cout`、`overflow` 标志是否正确

## 修改的文件

1. **rtl/Registers.v**: 修改初始值，x1=15, x2=10, x3=5
2. **rtl/Ins_buffer.v**: 添加完整的 ALU 测试指令序列
